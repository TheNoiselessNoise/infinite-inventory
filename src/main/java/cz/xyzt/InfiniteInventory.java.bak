package cz.xyzt;

import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.inventory.Inventory;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.nbt.NbtOps;
import net.minecraft.registry.Registries;
import net.minecraft.registry.RegistryWrapper;
import net.minecraft.util.Identifier;
import net.minecraft.util.collection.DefaultedList;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

public class InfiniteInventory implements Inventory {
    private static final int DISPLAY_SIZE = 54; // 6 rows of 9 slots
    private DefaultedList<ItemStack> items = DefaultedList.ofSize(DISPLAY_SIZE, ItemStack.EMPTY);
    private boolean sortAlphabetically = true;
    private final Runnable markDirtyCallback;
    private String lastSearchTerm = "";

    public InfiniteInventory(Runnable markDirtyCallback) {
        this.markDirtyCallback = markDirtyCallback;
    }

    public boolean isSortAlphabetically() {
        return sortAlphabetically;
    }

    public List<ItemStack> getAllItems() {
        return items;
    }

    @Override
    public int size() {
        return DISPLAY_SIZE;
    }

    @Override
    public boolean isEmpty() {
        return items.stream().allMatch(ItemStack::isEmpty);
    }

    @Override
    public ItemStack getStack(int slot) {
        return slot < items.size() ? items.get(slot) : ItemStack.EMPTY;
    }

    @Override
    public ItemStack removeStack(int slot, int amount) {
        if (slot < items.size()) {
            ItemStack stack = items.get(slot);
            if (amount >= stack.getCount()) {
                items.set(slot, ItemStack.EMPTY);
                markDirty();
                return stack;
            } else {
                ItemStack split = stack.split(amount);
                if (stack.isEmpty()) {
                    items.set(slot, ItemStack.EMPTY);
                }
                markDirty();
                return split;
            }
        }
        return ItemStack.EMPTY;
    }

    @Override
    public ItemStack removeStack(int slot) {
        if (slot < items.size()) {
            ItemStack stack = items.get(slot);
            items.set(slot, ItemStack.EMPTY);
            markDirty();
            return stack;
        }
        return ItemStack.EMPTY;
    }

    @Override
    public void setStack(int slot, ItemStack stack) {
        while (items.size() <= slot) {
            items.add(ItemStack.EMPTY);
        }
        items.set(slot, stack);
        markDirty();
    }

    @Override
    public void markDirty() {
        if (this.markDirtyCallback != null) {
            this.markDirtyCallback.run();
        }
    }

    @Override
    public boolean canPlayerUse(PlayerEntity player) {
        return true;
    }

    @Override
    public void clear() {
        items.clear();
        markDirty();
    }

    public List<ItemStack> getFilteredAndSortedItems(String searchTerm) {
        return items.stream()
            .filter(stack -> !stack.isEmpty() && stack.getName().getString().toLowerCase().contains(searchTerm.toLowerCase()))
            .sorted((a, b) -> sortAlphabetically 
                ? a.getName().getString().compareToIgnoreCase(b.getName().getString())
                : Integer.compare(b.getCount(), a.getCount()))
            .collect(Collectors.toList());
    }

    public void updateDisplayedItems(String searchTerm) {
        lastSearchTerm = searchTerm;
        List<ItemStack> filteredItems = getFilteredAndSortedItems(searchTerm);

        for (int i = 0; i < Math.min(DISPLAY_SIZE, filteredItems.size()); i++) {
            items.add(filteredItems.get(i));
        }
        while (items.size() < DISPLAY_SIZE) {
            items.add(ItemStack.EMPTY);
        }
    }

    public void toggleSortMode() {
        sortAlphabetically = !sortAlphabetically;
        updateDisplayedItems(lastSearchTerm);
    }

    public void syncWithClient(List<ItemStack> serverItems) {
        this.items.clear();
        this.items.addAll(serverItems);
        updateDisplayedItems(lastSearchTerm);
        markDirty();
    }

    public void addItem(ItemStack stack) {
        for (ItemStack existingStack : items) {
            if (canCombine(existingStack, stack)) {
                int spaceLeft = existingStack.getMaxCount() - existingStack.getCount();
                int amountToAdd = Math.min(spaceLeft, stack.getCount());
                existingStack.increment(amountToAdd);
                stack.decrement(amountToAdd);
                if (stack.isEmpty()) {
                    markDirty();
                    return;
                }
            }
        }
        if (!stack.isEmpty()) {
            items.add(stack.copy());
        }
        markDirty();
    }

    private boolean canCombine(ItemStack stack1, ItemStack stack2) {
        return !stack1.isEmpty() && !stack2.isEmpty() && 
            stack1.isOf(stack2.getItem()) && 
            ItemStack.areItemsEqual(stack1, stack2);
    }

    public NbtCompound writeNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        NbtList nbtTagList = new NbtList();
        for (int i = 0; i < items.size(); i++) {
            ItemStack stack = items.get(i);

            if (!stack.isEmpty()) {
                NbtCompound itemTag = new NbtCompound();
                itemTag.putInt("Slot", i);
                Identifier id = Registries.ITEM.getId(stack.getItem());
                itemTag.put("Item", NbtOps.INSTANCE.createString(id.toString()));
                itemTag.put("Count", NbtOps.INSTANCE.createInt(stack.getCount()));
                nbtTagList.add(itemTag);
            }
        }

        NbtCompound newNbt = new NbtCompound();
        newNbt.put("Items", nbtTagList);
        newNbt.putBoolean("SortAlphabetically", sortAlphabetically);
        return newNbt;
    }

    public void readNbt(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup) {
        NbtList listNbt = nbt.getList("Items", 10); // 10 is the NBT type for Compound
        items.clear();
        for (int i = 0; i < listNbt.size(); i++) {
            NbtCompound itemNbt = listNbt.getCompound(i);
            int slot = itemNbt.getInt("Slot");
            String itemId = itemNbt.getString("Item");
            int count = itemNbt.getInt("Count");
            
            Optional<Item> optionalItem = Registries.ITEM.getOrEmpty(Identifier.of(itemId));
            if (optionalItem.isPresent()) {
                ItemStack stack = new ItemStack(optionalItem.get(), count);
                while (items.size() <= slot) {
                    items.add(ItemStack.EMPTY);
                }
                items.set(slot, stack);
            }
        }
        sortAlphabetically = nbt.getBoolean("SortAlphabetically");
        updateDisplayedItems(lastSearchTerm);
    }
}