package cz.xyzt;

import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;

import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.ingame.HandledScreen;
import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.screen.slot.Slot;
import net.minecraft.screen.slot.SlotActionType;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.MathHelper;

import java.util.List;

public class InfiniteInventoryScreen extends HandledScreen<InfiniteInventoryScreenHandler> {
    private static final Identifier TEXTURE = Identifier.of("textures/gui/container/generic_54.png");
    private static final int ROWS = 6;
    private static final int COLUMNS = 9;
    private static final int SLOT_SIZE = 18;
    private static final int SCROLLBAR_WIDTH = 12;
    private static final int SCROLLBAR_HEIGHT = 15;
    
    private TextFieldWidget searchBar;
    private ButtonWidget sortButton;
    private InfiniteInventory inventory;
    private float scrollPosition = 0;
    private int scrollOffset = 0;
    private boolean scrolling = false;

    public InfiniteInventoryScreen(InfiniteInventoryScreenHandler handler, PlayerInventory inventory, Text title) {
        super(handler, inventory, title);
        this.inventory = handler.getInventory();
        this.backgroundWidth = 176;
        this.backgroundHeight = 114 + ROWS * SLOT_SIZE;
        this.playerInventoryTitleY = this.backgroundHeight - 94;
    }

    @Override
    protected void init() {
        super.init();
        
        // Add search bar
        this.searchBar = new TextFieldWidget(this.textRenderer, this.x + 82, this.y + 6, 80, 12, Text.of("Search..."));
        this.searchBar.setMaxLength(50);
        this.searchBar.setVisible(true);
        this.searchBar.setEditableColor(16777215);
        this.searchBar.setDrawsBackground(true);
        this.addDrawableChild(this.searchBar);

        // Add sort button
        this.sortButton = ButtonWidget.builder(Text.of("Sort: A-Z"), button -> {
            inventory.toggleSortMode();
            button.setMessage(Text.of("Sort: " + (inventory.isSortAlphabetically() ? "A-Z" : "Count")));
            updateInventoryContents();
        }).dimensions(this.x + 180, this.y + 4, 60, 16).build();
        this.addDrawableChild(this.sortButton);
    }

    @Override
    protected void drawBackground(DrawContext context, float delta, int mouseX, int mouseY) {
        int x = this.x;
        int y = this.y;
        context.drawTexture(TEXTURE, x, y, 0, 0, this.backgroundWidth, this.backgroundHeight);
        
        // Draw scrollbar
        int scrollbarX = x + 175;
        int scrollbarY = y + 18 + (int)((float)(93 - SCROLLBAR_HEIGHT) * this.scrollPosition);
        context.drawTexture(TEXTURE, scrollbarX, scrollbarY, 232 + (this.isScrollBarActive() ? 0 : 12), 0, SCROLLBAR_WIDTH, SCROLLBAR_HEIGHT);
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        this.renderBackground(context, mouseX, mouseY, delta);
        super.render(context, mouseX, mouseY, delta);
        this.drawMouseoverTooltip(context, mouseX, mouseY);
        searchBar.render(context, mouseX, mouseY, delta);
        sortButton.render(context, mouseX, mouseY, delta);
    }

    @Override
    protected void drawForeground(DrawContext context, int mouseX, int mouseY) {
        context.drawText(this.textRenderer, this.title, 8, 6, 4210752, false);
        context.drawText(this.textRenderer, this.playerInventoryTitle, 8, this.playerInventoryTitleY, 4210752, false);
    }

    @Override
    public boolean mouseDragged(double mouseX, double mouseY, int button, double deltaX, double deltaY) {
        if (this.scrolling) {
            int i = this.y + 18;
            int j = i + 93;
            this.scrollPosition = ((float)mouseY - (float)i - 7.5F) / ((float)(j - i) - 15.0F);
            this.scrollPosition = MathHelper.clamp(this.scrollPosition, 0.0F, 1.0F);
            this.scrollOffset = (int)((double)(this.scrollPosition * this.getMaxScroll()) + 0.5D) * COLUMNS;
            this.updateInventoryContents();
            return true;
        }
        return super.mouseDragged(mouseX, mouseY, button, deltaX, deltaY);
    }

    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (button == 0 && this.isPointOverScrollBar(mouseX, mouseY)) {
            this.scrolling = this.isScrollBarActive();
            return true;
        }

        int slotIndex = getSlotIndexAt(mouseX, mouseY);
        if (slotIndex >= 0) {
            this.onMouseClick(this.handler.slots.get(slotIndex), slotIndex, button, SlotActionType.PICKUP);
            return true;
        }

        return super.mouseClicked(mouseX, mouseY, button);
    }

    @Override
    public boolean mouseReleased(double mouseX, double mouseY, int button) {
        if (button == 0) {
            this.scrolling = false;
        }
        return super.mouseReleased(mouseX, mouseY, button);
    }

    private boolean isScrollBarActive() {
        return this.inventory.size() > ROWS * COLUMNS;
    }

    private boolean isPointOverScrollBar(double mouseX, double mouseY) {
        int i = this.x + 175;
        int j = this.y + 18;
        int k = i + 12;
        int l = j + 93;
        return mouseX >= (double)i && mouseY >= (double)j && mouseX < (double)k && mouseY < (double)l;
    }

    private int getMaxScroll() {
        return (this.inventory.size() + COLUMNS - 1) / COLUMNS - ROWS;
    }

    @Override
    protected void handledScreenTick() {
        super.handledScreenTick();
        // updateSlotPositions();
    }

    @Override
    protected void drawSlot(DrawContext context, Slot slot) {
        int index = slot.getIndex();
        int scrolledRows = (int) (scrollPosition * getMaxScroll());
        int firstVisibleIndex = scrolledRows * COLUMNS;
        int lastVisibleIndex = firstVisibleIndex + (ROWS * COLUMNS);

        if (index >= firstVisibleIndex && index < lastVisibleIndex && slot.inventory == this.inventory) {
            int adjustedIndex = index - firstVisibleIndex;
            int row = adjustedIndex / COLUMNS;
            int col = adjustedIndex % COLUMNS;

            int x = this.x + 8 + col * SLOT_SIZE;
            int y = this.y + 18 + row * SLOT_SIZE;

            // Draw slot contents without additional background
            context.drawItem(slot.getStack(), x, y);
            context.drawItemInSlot(this.textRenderer, slot.getStack(), x, y);
        } else if (slot.inventory instanceof PlayerInventory) {
            // Draw player inventory slots normally
            int x = this.x + slot.x;
            int y = this.y + slot.y;
            context.drawItem(slot.getStack(), x, y);
            context.drawItemInSlot(this.textRenderer, slot.getStack(), x, y);
        }
    }

    private int getSlotIndexAt(double mouseX, double mouseY) {
        int scrolledRows = (int) (scrollPosition * getMaxScroll());
        int firstVisibleIndex = scrolledRows * COLUMNS;
        int relativeX = (int) (mouseX - this.x - 8);
        int relativeY = (int) (mouseY - this.y - 18);

        if (relativeX >= 0 && relativeX < COLUMNS * SLOT_SIZE && relativeY >= 0 && relativeY < ROWS * SLOT_SIZE) {
            int col = relativeX / SLOT_SIZE;
            int row = relativeY / SLOT_SIZE;
            int index = firstVisibleIndex + (row * COLUMNS + col);
            if (index < this.inventory.size()) {
                return index;
            }
        }

        // Check player inventory slots
        int playerInvY = this.y + this.backgroundHeight - 94;
        if (mouseX >= this.x + 8 && mouseX < this.x + 8 + 9 * SLOT_SIZE) {
            if (mouseY >= playerInvY && mouseY < playerInvY + 3 * SLOT_SIZE) {
                int row = (int) ((mouseY - playerInvY) / SLOT_SIZE);
                int col = (int) ((mouseX - this.x - 8) / SLOT_SIZE);
                return this.inventory.size() + row * 9 + col;
            } else if (mouseY >= playerInvY + 58 && mouseY < playerInvY + 58 + SLOT_SIZE) {
                int col = (int) ((mouseX - this.x - 8) / SLOT_SIZE);
                return this.inventory.size() + 27 + col;
            }
        }

        return -1;
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (this.searchBar.keyPressed(keyCode, scanCode, modifiers)) {
            updateInventoryContents();
            return true;
        }
        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    @Override
    public boolean charTyped(char chr, int modifiers) {
        if (this.searchBar.charTyped(chr, modifiers)) {
            updateInventoryContents();
            return true;
        }
        return super.charTyped(chr, modifiers);
    }

    private void updateInventoryContents() {
        String searchTerm = searchBar.getText().toLowerCase();
        updateDisplayedItems(searchTerm);
        scrollPosition = 0;
    }

    private void updateDisplayedItems(String searchTerm) {
        InfiniteInventory inventory = this.handler.getInventory();
        List<ItemStack> filteredItems = inventory.getFilteredAndSortedItems(searchTerm);
        for (int i = 0; i < inventory.size(); i++) {
            int index = i + scrollOffset;
            if (index < filteredItems.size()) {
                inventory.setStack(i, filteredItems.get(index));
            } else {
                inventory.setStack(i, ItemStack.EMPTY);
            }
        }
    }
}